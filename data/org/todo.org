
* 
** Mon Oct 26 08:00:14 2009 (- recentf and other modes still writting to ~/)

- recentf and other modes still writting to ~/
- company not working

/home/marco/emacs/personal/cunene/cunene-misc.el

** Mon Oct 26 08:01:28 2009 (checkout all the fixmes.)

checkout all the fixmes.

/home/marco/emacs/personal/cunene/cunene-misc.el

** Mon Oct 26 09:09:11 2009 (- add auto-fill-mode to comments in c-mode)

- add auto-fill-mode to comments in c-mode

** Tue Oct 27 08:02:41 2009 (- gdb mi crashes)

- comment mode not always works

** Tue Oct 27 08:07:11 2009 (- Do we need ido mode for command completion?)

- Do we need ido mode for command completion?

** Wed Oct 28 11:39:25 2009 (- boost::shared_ptr completion is not working in semantic)

- boost::shared_ptr completion is not working in semantic

** Sun Nov  1 15:55:49 2009 (- bookmarks only seem to work on a local buffer. )

- bookmarks only seem to work on a local buffer.

** Wed Nov  4 09:09:17 2009 (- add key to entities in the ontology)

- add entity_test base class to contain all the common unit test
  infrastructure to all entities in the ontology.

/home/marco/code/kitanda/trading/cpp/src/test/ontology/country_test.hpp

** Mon Dec 21 09:45:33 2009 (overload function return value (for load()) to return number)

overload function return value (for load()) to return number of rows.

/home/marco/code/kitanda/trading/cpp/src/test/ontology/country_test.cpp

** Mon Dec 21 10:20:35 2009 (saving should return the new version of entity.)

saving should return the new version of entity.

/home/marco/code/kitanda/risk/doc/definitions.tex

** Mon Dec 21 11:46:43 2009 (how do we determine all the market data we need to load for )

how do we determine all the market data we need to load for a given
trader book collection?

book graph:

- fx
  - emerging
    - latin america (latam)
      - argies
      - brazil
  - swissies
  - cable

portfolio graph:

- tom (trader)
  - portfolio 1
    - emerging
    - swissies


portfolios p(portfolio_manager.load());
tom_p1 = find_toms_portfolio(); // chosen by user

...
trading::ontology_graph_manager ogm;
ogm.load_by_portfolio(tom_p1.key());

// go to all the entity_managers and call load_by_portfolio
// in risk::ontology, overload the load_statement parameter
// to pass in the load_by_portfolio sproc.

books b(book_graph_manager.load());
models m(model_graph_manager.load());
ontology o(ontology_builder.build(b, m);

market_data_dependency_evaluator mdde;
mdde.add_models(o.models());
mdde.add_instruments(o.instruments());
mdde.get_dependencies();
...

too complicated. what if there is a sproc that takes:

- book id or trader book collection

and returns all the required curves? this would require:

- a default model, for when loading a book that is not part of a
  trader book collection.
- a model set, associated with a trader book collection
- a complex sproc that intersects the model set with the book
  collection and returns all affected curves.


/home/marco/code/kitanda/trading/cpp/src/test/ontology/country_test.cpp

** Mon Dec 21 14:16:46 2009 (ask one of the trio to try and build the code under windows.)

ask one of the trio to try and build the code under windows. need to
give them a list of dependencies:

- postgres, changes to config required
- libpq, libpqxx
- boost

** Tue Dec 22 09:34:21 2009 (add versioning to project plan)

add versioning to project plan

/home/marco/code/kitanda/risk/doc/entities.txt

** Tue Dec 22 10:21:28 2009 (add test data generators to project plan.)

add test data generators to project plan.

/home/marco/code/kitanda/trading/cpp/include/trading/test_data/generator.hpp

** Tue Dec 22 20:13:02 2009 (- create source data files for the test data, that can be sc)

- create source data files for the test data, that can be scripted to
  produce c++ and sql. even without the scripts, this is useful.

** Sat Jan 30 15:55:07 2010 (- why do we need macros for logging? can one not simply have)

- why do we need macros for logging? can one not simply have a global
  operator<<(LOG, LEVEL) where LOG does not inherit in any way from
  streams but has a stream inside it, e.g.:

std::ostream&
operator<<(LOG& log, const LEVEL& level) {
     if (log.level() == level) {
        log.output_stream() << level;
        return log.output_stream();
}
** Sat Feb  6 22:55:30 2010 (test)
   test
